"use strict";(self.webpackChunkcredo_ts_docs=self.webpackChunkcredo_ts_docs||[]).push([[8368],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=d(n),m=a,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||i;return n?r.createElement(h,o(o({ref:t},c),{},{components:n})):r.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:a,o[1]=s;for(var d=2;d<i;d++)o[d]=n[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>o});var r=n(67294),a=n(86010);const i={tabItem:"tabItem_Ymn6"};function o(e){let{children:t,hidden:n,className:o}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(i.tabItem,o),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>N});var r=n(87462),a=n(67294),i=n(86010),o=n(12466),s=n(16550),l=n(91980),d=n(67392),c=n(50012);function u(e){return function(e){return a.Children.map(e,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:a}}=e;return{value:t,label:n,attributes:r,default:a}}))}function p(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??u(n);return function(e){const t=(0,d.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const r=(0,s.k6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(i),(0,a.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(r.location.search);t.set(i,e),r.replace({...r.location,search:t.toString()})}),[i,r])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,i=p(e),[o,s]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:i}))),[l,d]=h({queryString:n,groupId:r}),[u,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,i]=(0,c.Nk)(n);return[r,(0,a.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:r}),y=(()=>{const e=l??u;return m({value:e,tabValues:i})?e:null})();(0,a.useLayoutEffect)((()=>{y&&s(y)}),[y]);return{selectedValue:o,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);s(e),d(e),g(e)}),[d,g,i]),tabValues:i}}var y=n(72389);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function v(e){let{className:t,block:n,selectedValue:s,selectValue:l,tabValues:d}=e;const c=[],{blockElementScrollPositionUntilNextRender:u}=(0,o.o5)(),p=e=>{const t=e.currentTarget,n=c.indexOf(t),r=d[n].value;r!==s&&(u(t),l(r))},m=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},t)},d.map((e=>{let{value:t,label:n,attributes:o}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>c.push(e),onKeyDown:m,onClick:p},o,{className:(0,i.Z)("tabs__item",f.tabItem,o?.className,{"tabs__item--active":s===t})}),n??t)})))}function b(e){let{lazy:t,children:n,selectedValue:r}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==r}))))}function k(e){const t=g(e);return a.createElement("div",{className:(0,i.Z)("tabs-container",f.tabList)},a.createElement(v,(0,r.Z)({},e,t)),a.createElement(b,(0,r.Z)({},e,t)))}function N(e){const t=(0,y.Z)();return a.createElement(k,(0,r.Z)({key:String(t)},e))}},33172:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>u});var r=n(87462),a=(n(67294),n(3905)),i=n(74866),o=n(85162);const s={},l="Indy VDR",d={unversionedId:"getting-started/set-up/indy-vdr",id:"getting-started/set-up/indy-vdr",title:"Indy VDR",description:"Hyperledger Indy VDR, Verifiable Data Registry, can be used to connect to one or more Indy Node ledger pools given sets of genesis transactions. Methods are provided to construct ledger requests and send them to the validators, collecting the results and ensuring that there is a consensus between the nodes. In the context of Credo, we mainly leverage it to register, and resolve, schemas, credential definitions and DIDs.",source:"@site/guides/getting-started/set-up/indy-vdr.md",sourceDirName:"getting-started/set-up",slug:"/getting-started/set-up/indy-vdr",permalink:"/guides/getting-started/set-up/indy-vdr",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"AnonCreds",permalink:"/guides/getting-started/set-up/anoncreds"},next:{title:"cheqd",permalink:"/guides/getting-started/set-up/cheqd/"}},c={},u=[{value:"Installing Indy VDR",id:"installing-indy-vdr",level:3},{value:"Adding Indy VDR to the agent",id:"adding-indy-vdr-to-the-agent",level:3},{value:"Configuration",id:"configuration",level:3},{value:"indyVdr",id:"indyvdr",level:4},{value:"networks",id:"networks",level:4},{value:"indyNamespace",id:"indynamespace",level:5},{value:"<code>isProduction</code>",id:"isproduction",level:5},{value:"<code>genesisTransactions</code>",id:"genesistransactions",level:5},{value:"<code>connectOnStartup</code>",id:"connectonstartup",level:5},{value:"<code>transactionAuthorAgreement</code>",id:"transactionauthoragreement",level:5},{value:"<code>transactionAuthorAgreement.version</code>",id:"transactionauthoragreementversion",level:5},{value:"<code>transactionAuthorAgreement.acceptanceMechanism</code>",id:"transactionauthoragreementacceptancemechanism",level:5}],p={toc:u},m="wrapper";function h(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"indy-vdr"},"Indy VDR"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/hyperledger/indy-vdr"},"Hyperledger Indy VDR"),", Verifiable Data Registry, can be used to connect to one or more Indy Node ledger pools given sets of genesis transactions. Methods are provided to construct ledger requests and send them to the validators, collecting the results and ensuring that there is a consensus between the nodes. In the context of Credo, we mainly leverage it to register, and resolve, schemas, credential definitions and DIDs."),(0,a.kt)("h3",{id:"installing-indy-vdr"},"Installing Indy VDR"),(0,a.kt)("p",null,"When using Credo with Indy VDR, there are a few extra dependencies that need to be installed. We need to install the ",(0,a.kt)("inlineCode",{parentName:"p"},"@hyperledger/indy-vdr"),", which contains all the functionality to register objects on an Hyperledger Indy VDR. Secondly, we need to add native bindings for the specific platform ",(0,a.kt)("inlineCode",{parentName:"p"},"@hyperledger/indy-vdr-<platform>"),". Currently there are bindings for Node.JS, as ",(0,a.kt)("inlineCode",{parentName:"p"},"@hyperledger/indy-vdr-nodejs"),", and React Native as ",(0,a.kt)("inlineCode",{parentName:"p"},"@hyperlegder/indy-vdr-react-native"),"."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{label:"Node.JS",value:"tab1",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"yarn add @credo-ts/indy-vdr@^0.5.3 @hyperledger/indy-vdr-nodejs@^0.2.2\n"))),(0,a.kt)(o.Z,{label:"React Native",value:"tab2",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"yarn add @credo-ts/indy-vdr@^0.5.3 @hyperledger/indy-vdr-react-native@^0.2.2\n")))),(0,a.kt)("h3",{id:"adding-indy-vdr-to-the-agent"},"Adding Indy VDR to the agent"),(0,a.kt)("p",null,"After installing the dependencies, we can register the Indy VDR module on the agent."),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{label:"Node.JS",value:"tab1",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"showLineNumbers set-up-indy-vdr.ts section-1",showLineNumbers:!0,"set-up-indy-vdr.ts":!0,"section-1":!0},""))),(0,a.kt)(o.Z,{label:"React Native",value:"tab2",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"showLineNumbers set-up-indy-vdr-rn.ts section-1",showLineNumbers:!0,"set-up-indy-vdr-rn.ts":!0,"section-1":!0},"")))),(0,a.kt)("h3",{id:"configuration"},"Configuration"),(0,a.kt)("p",null,"As you can see below, the Indy VDR module takes the native bindings and a list of networks. This list of networks will be used to resolve and register objects on."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"typescript showLineNumbers set-up-indy-vdr-config.ts section-1",typescript:!0,showLineNumbers:!0,"set-up-indy-vdr-config.ts":!0,"section-1":!0},"")),(0,a.kt)("h4",{id:"indyvdr"},"indyVdr"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Type"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"IndyVdr")),(0,a.kt)("p",null,"the ",(0,a.kt)("inlineCode",{parentName:"p"},"indyVdr")," key takes a class that implements all the native bindings for Indy VDR. This can be imoprted from the ",(0,a.kt)("inlineCode",{parentName:"p"},"@hyperledger/indy-vdr-nodejs")," package or the ",(0,a.kt)("inlineCode",{parentName:"p"},"@hyperledger/indy-vdr-react-native")," package."),(0,a.kt)("h4",{id:"networks"},"networks"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Type"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"IndyVdrPoolConfig[]")),(0,a.kt)("p",null,"An array of indy networks to connect to. The list can contain the following object and it must ",(0,a.kt)("a",{parentName:"p",href:"#indyledgersgenesistransactions"},(0,a.kt)("inlineCode",{parentName:"a"},"genesisTransactions")),"."),(0,a.kt)("h5",{id:"indynamespace"},"indyNamespace"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Type"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"string")),(0,a.kt)("p",null,"The Indy namespace aka the name identifying the name of the network connecting to. See also ",(0,a.kt)("a",{parentName:"p",href:"https://hyperledger.github.io/indy-did-method/#indy-did-method-identifiers"},"indy did method identifiers")),(0,a.kt)("h5",{id:"isproduction"},(0,a.kt)("inlineCode",{parentName:"h5"},"isProduction")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Type"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean")),(0,a.kt)("p",null,"Whether the ledger is a production ledger. This is used for detecting which ledger to use in case of unqualified identifiers as production ledgers have priority."),(0,a.kt)("h5",{id:"genesistransactions"},(0,a.kt)("inlineCode",{parentName:"h5"},"genesisTransactions")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Type"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"string")),(0,a.kt)("p",null,"Stringified JSON object of the transaction."),(0,a.kt)("h5",{id:"connectonstartup"},(0,a.kt)("inlineCode",{parentName:"h5"},"connectOnStartup")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Type"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean")),(0,a.kt)("p",null,"Whether to connect to the ledger on startup. Defaults to ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,a.kt)("h5",{id:"transactionauthoragreement"},(0,a.kt)("inlineCode",{parentName:"h5"},"transactionAuthorAgreement")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Type"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"TransactionAuthorAgreement")),(0,a.kt)("p",null,"JSON representation specifying the version and acceptance mechanism. The version is the unique version of the transaction author agreement acceptance mechanism list (AML). The acceptance mechanism refers to the acceptance mechanism label of the item in the AML. For more details you may consult the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/hyperledger/indy-node/blob/master/docs/source/transactions.md#transaction_author_agreement_aml"},"indy-node docs on AML")),(0,a.kt)("h5",{id:"transactionauthoragreementversion"},(0,a.kt)("inlineCode",{parentName:"h5"},"transactionAuthorAgreement.version")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Type"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"string")),(0,a.kt)("p",null,"The version of the AML acceptance mechanism. This is a string representation of a version number e.g. '1' or '1.4'"),(0,a.kt)("h5",{id:"transactionauthoragreementacceptancemechanism"},(0,a.kt)("inlineCode",{parentName:"h5"},"transactionAuthorAgreement.acceptanceMechanism")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Type"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"string")),(0,a.kt)("p",null,"The acceptance mechanism to choose. This ",(0,a.kt)("em",{parentName:"p"},"must")," be ",(0,a.kt)("em",{parentName:"p"},"one")," of the available labels of the acceptance mechanisms key-value pairs in the AML e.g. 'EULA'."))}h.isMDXComponent=!0}}]);